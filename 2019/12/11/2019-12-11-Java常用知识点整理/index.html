<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java常用知识点整理 | Ikkyu</title><meta name="description" content="Java部分知识点回顾"><meta name="keywords" content="回顾总结"><meta name="author" content="谭蕴修"><meta name="copyright" content="谭蕴修"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Java常用知识点整理"><meta name="twitter:description" content="Java部分知识点回顾"><meta name="twitter:image" content="http://eqgis.cn:13147/img/java.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java常用知识点整理"><meta property="og:url" content="http://www.eqgis.cn/2019/12/11/2019-12-11-Java%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><meta property="og:site_name" content="Ikkyu"><meta property="og:description" content="Java部分知识点回顾"><meta property="og:image" content="http://eqgis.cn:13147/img/java.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.eqgis.cn/2019/12/11/2019-12-11-Java%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><link rel="prev" title="时间格式转换、JDBC以及动态菜单" href="/http:/www.eqgis.cn/2019/12/14/2019-12-14-JDBC%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95/"><link rel="next" title="SQL部分知识点回顾" href="/http:/www.eqgis.cn/2019/12/10/2019-12-10-SQL%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e8f802492e90c6753df90ed95d9f395";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.eqgis.cn","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ikkyu</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="https://poem.eqgis.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-heart"></i><span> 诗歌主页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://tool.eqgis.cn:10609/blog" target="_blank" rel="noopener"><i class="fa-fw fa fa-calendar-check-o"></i><span> Memo</span></a></li><li><a class="site-page" href="http://tool.eqgis.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-wrench"></i><span> Tool</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="https://poem.eqgis.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-heart"></i><span> 诗歌主页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://tool.eqgis.cn:10609/blog" target="_blank" rel="noopener"><i class="fa-fw fa fa-calendar-check-o"></i><span> Memo</span></a></li><li><a class="site-page" href="http://tool.eqgis.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-wrench"></i><span> Tool</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#类的定义和声明"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">类的定义和声明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#类的实例化"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">类的实例化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#a、使用new关键字"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">a、使用new关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#b、使用Class类的newInstance方法"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">b、使用Class类的newInstance方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#c、使用Constructor类的newInstance方法"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">c、使用Constructor类的newInstance方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#d、使用clone方法"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">d、使用clone方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#e、使用反序列化"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">e、使用反序列化</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#接口的定义和声明"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">接口的定义和声明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#接口的实现"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">接口的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#常用类和数据结构-String类"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">常用类和数据结构-String类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#String常用方法"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">String常用方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#String、StringBuffer和StringBuilder使用比较"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">String、StringBuffer和StringBuilder使用比较</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#StringBuffer构造方法"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">StringBuffer构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#StringBuffer删除方法"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">StringBuffer删除方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#StringBuffer替换方法"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">StringBuffer替换方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#StringBuffer反转功能"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">StringBuffer反转功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#截取功能"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">截取功能</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#常用类和数据结构-包装类"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">常用类和数据结构-包装类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#包装类的数值转换"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">包装类的数值转换</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#常用类和数据结构-容器类"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">常用类和数据结构-容器类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#IO流"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">IO流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#字节流"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">字节流</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#字符流"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">字符流</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#高效流效率对比"><span class="toc_mobile_items-number">10.3.</span> <span class="toc_mobile_items-text">高效流效率对比</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Java的异常"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">Java的异常</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#Error（错误）"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">Error（错误）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#Exception（异常）"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">Exception（异常）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#Exception这种异常又分为两类：运行时异常和编译异常"><span class="toc_mobile_items-number">11.2.1.</span> <span class="toc_mobile_items-text">Exception这种异常又分为两类：运行时异常和编译异常</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#可查异常与不可查异常：java的所有异常可以分为可查异常（checked-exception）和不可查异常（unchecked-exception）。"><span class="toc_mobile_items-number">11.2.2.</span> <span class="toc_mobile_items-text">可查异常与不可查异常：java的所有异常可以分为可查异常（checked exception）和不可查异常（unchecked exception）。</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#对于不同的异常，java采用不同的异常处理方式。"><span class="toc_mobile_items-number">11.2.3.</span> <span class="toc_mobile_items-text">对于不同的异常，java采用不同的异常处理方式。</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#类的定义和声明"><span class="toc-number">1.</span> <span class="toc-text">类的定义和声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的实例化"><span class="toc-number">2.</span> <span class="toc-text">类的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a、使用new关键字"><span class="toc-number">2.1.</span> <span class="toc-text">a、使用new关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b、使用Class类的newInstance方法"><span class="toc-number">2.2.</span> <span class="toc-text">b、使用Class类的newInstance方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c、使用Constructor类的newInstance方法"><span class="toc-number">2.3.</span> <span class="toc-text">c、使用Constructor类的newInstance方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d、使用clone方法"><span class="toc-number">2.4.</span> <span class="toc-text">d、使用clone方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e、使用反序列化"><span class="toc-number">2.5.</span> <span class="toc-text">e、使用反序列化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口的定义和声明"><span class="toc-number">3.</span> <span class="toc-text">接口的定义和声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口的实现"><span class="toc-number">4.</span> <span class="toc-text">接口的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用类和数据结构-String类"><span class="toc-number">5.</span> <span class="toc-text">常用类和数据结构-String类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String常用方法"><span class="toc-number">5.1.</span> <span class="toc-text">String常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String、StringBuffer和StringBuilder使用比较"><span class="toc-number">6.</span> <span class="toc-text">String、StringBuffer和StringBuilder使用比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer构造方法"><span class="toc-number">6.1.</span> <span class="toc-text">StringBuffer构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer删除方法"><span class="toc-number">6.2.</span> <span class="toc-text">StringBuffer删除方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer替换方法"><span class="toc-number">6.3.</span> <span class="toc-text">StringBuffer替换方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer反转功能"><span class="toc-number">6.4.</span> <span class="toc-text">StringBuffer反转功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#截取功能"><span class="toc-number">6.5.</span> <span class="toc-text">截取功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用类和数据结构-包装类"><span class="toc-number">7.</span> <span class="toc-text">常用类和数据结构-包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#包装类的数值转换"><span class="toc-number">8.</span> <span class="toc-text">包装类的数值转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用类和数据结构-容器类"><span class="toc-number">9.</span> <span class="toc-text">常用类和数据结构-容器类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO流"><span class="toc-number">10.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字节流"><span class="toc-number">10.1.</span> <span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符流"><span class="toc-number">10.2.</span> <span class="toc-text">字符流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#高效流效率对比"><span class="toc-number">10.3.</span> <span class="toc-text">高效流效率对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java的异常"><span class="toc-number">11.</span> <span class="toc-text">Java的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Error（错误）"><span class="toc-number">11.1.</span> <span class="toc-text">Error（错误）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Exception（异常）"><span class="toc-number">11.2.</span> <span class="toc-text">Exception（异常）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Exception这种异常又分为两类：运行时异常和编译异常"><span class="toc-number">11.2.1.</span> <span class="toc-text">Exception这种异常又分为两类：运行时异常和编译异常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#可查异常与不可查异常：java的所有异常可以分为可查异常（checked-exception）和不可查异常（unchecked-exception）。"><span class="toc-number">11.2.2.</span> <span class="toc-text">可查异常与不可查异常：java的所有异常可以分为可查异常（checked exception）和不可查异常（unchecked exception）。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#对于不同的异常，java采用不同的异常处理方式。"><span class="toc-number">11.2.3.</span> <span class="toc-text">对于不同的异常，java采用不同的异常处理方式。</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://eqgis.cn:13147/img/java.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Java常用知识点整理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-12-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-11</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/">JAVA</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">6.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 23 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h4 id="类的定义和声明"><a href="#类的定义和声明" class="headerlink" title="类的定义和声明"></a>类的定义和声明</h4><p>定义：基于面向对象思想，显示生活中具有共同特性对象的抽象就称之为类。</p>
<p>声明：在Java中，通过关键字class来声明类，类声明语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//定义类属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	属性A的类型 属性A;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	属性B的类型 属性B;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	……</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	属性N的类型 属性N;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	方法a：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	……</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	方法n：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h4><p>创建对象的几种方式（）<br><code>简言之，即是:new/反射/clone()/反序列化</code></p>
<pre><code>a.使用new关键字                  } → 调用了构造函数
b.使用Class类的newInstance方法          } → 调用了构造函数
c.使用Constructor类的newInstance方法   } → 调用了构造函数
d.使用clone方法                             } → 没有调用构造函数
e.使用反序列化                             } → 没有调用构造函数</code></pre><h5 id="a、使用new关键字"><a href="#a、使用new关键字" class="headerlink" title="a、使用new关键字"></a>a、使用new关键字</h5><p>这是最常见也是最简单的创建对象的方式了。通过这种方式，我们可以调用任意的构造函数(无参的和带参数的)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Employee emp1 = <span class="keyword">new</span> Employee();</span></pre></td></tr></table></figure>


<h5 id="b、使用Class类的newInstance方法"><a href="#b、使用Class类的newInstance方法" class="headerlink" title="b、使用Class类的newInstance方法"></a>b、使用Class类的newInstance方法</h5><p>这个newInstance方法调用无参的构造函数创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Employee emp2 = (Employee) Class.forName(<span class="string">"com.example.Employee"</span>).newInstance();</span></pre></td></tr></table></figure>

<p>  或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Employee emp2 = Employee<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span></pre></td></tr></table></figure>

<h5 id="c、使用Constructor类的newInstance方法"><a href="#c、使用Constructor类的newInstance方法" class="headerlink" title="c、使用Constructor类的newInstance方法"></a>c、使用Constructor类的newInstance方法</h5><p>和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    Constructor&lt;Employee&gt; constructor = Employee<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">​    Employee emp3 = constructor.newInstance();</span></pre></td></tr></table></figure>
<p>  事实上Class的newInstance方法内部调用Constructor的newInstance方法。</p>
<h5 id="d、使用clone方法"><a href="#d、使用clone方法" class="headerlink" title="d、使用clone方法"></a>d、使用clone方法</h5><p>无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。要使用clone方法，需要先实现Cloneable接口并实现其定义的clone方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Employee emp4 = (Employee) emp3.clone();</span></pre></td></tr></table></figure>


<h5 id="e、使用反序列化"><a href="#e、使用反序列化" class="headerlink" title="e、使用反序列化"></a>e、使用反序列化</h5><p>当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.obj"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">​    Employee emp5 = (Employee) in.readObject();</span></pre></td></tr></table></figure>

<h4 id="接口的定义和声明"><a href="#接口的定义和声明" class="headerlink" title="接口的定义和声明"></a>接口的定义和声明</h4><p>接口的概念：<br>    在Java中接口是一个全部由抽象方法组成的集合，接口需要用interface定义，里面只能有抽象的方法和常量。<br>定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i=<span class="number">10</span>;	<span class="comment">//全局常量前缀public static final</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;	<span class="comment">//抽象的方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>接口的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 接口列表</span></span></pre></td></tr></table></figure>
<p>补充：接口<br><code>a、没有变量的声明，可定义常量 //[public][static]（或[final]）常量；
b、只有方法的声明，没有方法的实现//[public][abstract]方法</code></p>
<p>`</p>
<h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>接口在定义后，就可以在类中实现该接口。在类中实现接口可以使用关键字implements<br>[修饰符] class&lt;类名&gt;[extends 父类名][implents 接口列表]{}</p>
<h4 id="常用类和数据结构-String类"><a href="#常用类和数据结构-String类" class="headerlink" title="常用类和数据结构-String类"></a>常用类和数据结构-String类</h4><p>以下来自Jdk1.8api<br><code>String类代表字符串。 Java程序中的所有字符串文字（例如&quot;abc&quot; ）都被实现为此类的实例。 
    字符串不变; 它们的值在创建后不能被更改。 字符串缓冲区支持可变字符串。 因为String对象是不可变的，它们可以被共享。 例如：</code></p>
<pre><code>    String str = &quot;abc&quot;;
相当于： 

    char data[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;};
    String str = new String(data);
以下是一些如何使用字符串的示例： 

    System.out.println(&quot;abc&quot;);
    String cde = &quot;cde&quot;;
    System.out.println(&quot;abc&quot; + cde);
    String c = &quot;abc&quot;.substring(2,3);
    String d = cde.substring(1, 2);
String类包括用于检查序列的各个字符的方法，用于比较字符串，搜索字符串，提取子字符串以及创建将所有字符翻译为大写或小写的字符串的副本。 案例映射基于Character类指定的Unicode标准版本。 </code></pre><p><code>Java语言为字符串连接运算符（+）提供特殊支持，并为其他对象转换为字符串。 字符串连接是通过StringBuilder （或StringBuffer ）类及其append方法实现的。 字符串转换是通过方法来实现toString ，由下式定义Object和继承由在Java中的所有类。 有关字符串连接和转换的其他信息，请参阅Gosling，Joy和Steele， Java语言规范 。</code></p>
<h5 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h5><p>常用length、isEmpty、equals、indexOf、charAt、subString、getChars、startsWith、endWith等方法。<br>public String substring(int beginIndex,int endIndex)返回一个字符串，该字符串是此字符串的子字符串。 子串开始于指定beginIndex并延伸到字符索引endIndex - 1 。 因此，子串的长度为endIndex-beginIndex 。 </p>
<p>public int indexOf(String str,<br>                   int fromIndex)返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 <code></code>public char charAt(int index)返回char指定索引处的值。 指数范围为0至length() - 1 。 该序列的第一个char值在索引0 ，下一个索引为1 ，依此类推，与数组索引一样。</p>
<p>public void getChars(int srcBegin,<br>                     int srcEnd,<br>                     char[] dst,<br>                     int dstBegin)将此字符串中的字符复制到目标字符数组中。<br>public int compareTo(String anotherString)按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值。</p>
<p>public boolean startsWith(String prefix)测试此字符串是否以指定的前缀开头。<br>参数<br>prefix - 前缀。<br>结果<br>true如果由参数表示的字符序列是由该字符串表示的字符序列的前缀; false否则。 还需要注意的是true如果参数为空字符串或等于该将被返回String如由所确定的对象equals(Object)方法。<br>endsWith类似<br>public int hashCode()返回此字符串的哈希码。 String对象的哈希代码计算为<br> s[0]<em>31^(n-1) + s[1]</em>31^(n-2) + … + s[n-1]</p>
<h4 id="String、StringBuffer和StringBuilder使用比较"><a href="#String、StringBuffer和StringBuilder使用比较" class="headerlink" title="String、StringBuffer和StringBuilder使用比较"></a>String、StringBuffer和StringBuilder使用比较</h4><p>String见上一条目</p>
<p>StringBuffer：可变字符串序列，线程安全</p>
<p>StringBuilder：可变字符串序列，线程不安全，高效</p>
<h5 id="StringBuffer构造方法"><a href="#StringBuffer构造方法" class="headerlink" title="StringBuffer构造方法"></a>StringBuffer构造方法</h5><p>StringBuffer() ：　　<br>    　　　　　　构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。（容量是可以自动扩容的）<br>    　　　　　　自己理解 ：创建一个空的字符序列（频繁的扩容很耗时）。<br>    　　StringBuffer(int capacity)<br>    　　　　　　构造一个不带字符，但具有指定初始容量的字符串缓冲区。<br>    　　　　　　自己理解 ：创建了一个空的字符序列，容量为capacity。<br>    　　StringBuffer(String str)<br>    　　　　　　构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。该字符串的初始容量为 16 加上字符串参数的长度。<br>    　　　　　　自己理解 ：创建了容量为 str.length+16容量的字符串序列，里面存储了字符串str。<br>        append()方法：（重写）<br>    　　StringBuffer append(Object obj)<br>    　　　　追加 Object 参数的字符串表示形式。<br>    　　　　　　注：调用的是toString（）方法，拼接的是toString方法返回的字符串。<br>    　　StringBuffer append(char[] str)<br>    　　　　将 char 数组参数的字符串表示形式追加到此序列。<br>    　　　　　　注：是将数组里的内容进行拼接，而不是调用toString（）<br>    　　StringBuffer append(boolean b)<br>    　　　　将 boolean 参数的字符串表示形式追加到序列。<br>    　　StringBuffer append(char c)<br>    　　　　将 char 参数的字符串表示形式追加到此序列。<br>    　　StringBuffer append(char[] str, int offset, int len)<br>    　　　　将 char 数组参数的子数组的字符串表示形式追加到此序列。<br>    　　StringBuffer append(CharSequence s)<br>    　　　　将指定的 CharSequence 追加到该序列。<br>    　　StringBuffer append(CharSequence s, int start, int end)<br>    　　　　将指定 CharSequence 的子序列追加到此序列。<br>    　　StringBuffer append(double d)<br>    　　　　将 double 参数的字符串表示形式追加到此序列。<br>    　　StringBuffer append(float f)<br>    　　　　将 float 参数的字符串表示形式追加到此序列。<br>    　　StringBuffer append(int i)<br>    　　　　将 int 参数的字符串表示形式追加到此序列。<br>    　　StringBuffer append(long lng)<br>    　　　　将 long 参数的字符串表示形式追加到此序列。<br>    　　StringBuffer append(String str)<br>    　　　　将指定的字符串追加到此字符序列。<br>    　　StringBuffer append(StringBuffer sb)<br>    　　　　将指定的 StringBuffer 追加到此序列中。</p>
<p>insert（）方法：（重写）<br>        StringBuffer insert(int offset, boolean b)<br>    　　　　将 boolean 参数的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int offset, char c)<br>    　　　　将 char 参数的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int offset, char[] str) 　　<br>    　　　　将 char 数组参数的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int index, char[] str, int offset, int len)<br>    　　　　将数组参数 str 的子数组的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int dstOffset, CharSequence s)<br>    　　　　将指定 CharSequence 插入此序列中。<br>    　　StringBuffer insert(int dstOffset, CharSequence s, int start, int end)<br>    　　　　将指定 CharSequence 的子序列插入此序列中。<br>    　　StringBuffer insert(int offset, double d)<br>    　　　　将 double 参数的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int offset, float f)<br>    　　　　将 float 参数的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int offset, int i)<br>    　　　　将 int 参数的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int offset, long l)<br>    　　　　将 long 参数的字符串表示形式插入此序列中。<br>    　　StringBuffer insert(int offset, Object obj)<br>    　　　　将 Object 参数的字符串表示形式插入此字符序列中。<br>    　　StringBuffer insert(int offset, String str)<br>　　　　将字符串插入此字符序列中。 `</p>
<h5 id="StringBuffer删除方法"><a href="#StringBuffer删除方法" class="headerlink" title="StringBuffer删除方法"></a>StringBuffer删除方法</h5><p>`     delete(int start, int end)<br>    　　移除此序列的子字符串中的字符。<br>    　　移除此序列的子字符串中的字符。该子字符串从指定的 start 处开始，一直到索引 end - 1 处的字符，如果不存在这种字符，则一直到序列尾部。如果 start 等于 end，则不发生任何更改。<br>    　　　　参数：（包左不包右）<br>    　　　　start - 起始索引（包含）。<br>    　　　　end - 结束索引（不包含）。<br>    StringBuffer deleteCharAStringBuffert(int index)<br>    　　移除此序列指定位置的 char。<br>    　　移除此序列指定位置的 char。此序列将缩短一个 char。<br>　　　　注：如果给定索引处的字符是增补字符，则此方法将不会移除整个字符。如果需要准确处理增补字符，那么可以通过调用 。</p>
<h5 id="StringBuffer替换方法"><a href="#StringBuffer替换方法" class="headerlink" title="StringBuffer替换方法"></a>StringBuffer替换方法</h5><p>StringBuffer replace(int start, int end, String str)<br>    　　使用给定 String 中的字符替换此序列的子字符串中的字符。该子字符串从指定的 start 处开始，一直到索引 end - 1 处的字符，如果不存在这种字符，则一直到序列尾部。先将子字符串中的字符移除，然后将指定的 String 插入 start。（如果需要，序列将延长以适应指定的字符串。）<br>    　　参数：（包左不包右）<br>    　　　　start - 起始索引（包含）。<br>    　　　　end - 结束索引（不包含）。<br>　　　　str - 将替换原有内容的字符串。 </p>
<h5 id="StringBuffer反转功能"><a href="#StringBuffer反转功能" class="headerlink" title="StringBuffer反转功能"></a>StringBuffer反转功能</h5><p>StringBuffer reverse()<br>　　概述:将此字符序列用其反转形式取代。</p>
<h5 id="截取功能"><a href="#截取功能" class="headerlink" title="截取功能"></a>截取功能</h5><p>String substring(int start)<br>    返回一个新的 String，它包含此字符序列当前所包含的字符子序列。该子字符串始于指定索引处的字符，一直到此字符串末尾。<br>    　　参数：<br>    　　　　start - 起始索引（包含）。 　　<br>    　　返回：(注意：上面个所写的方法修改的都是本身，而subString返回的是一个String类型的字符串)<br>    　　　　新的字符串。<br>        　String substring(int start, int end)<br>    　　　　返回一个新的 String，它包含此序列当前所包含的字符子序列。<br>    　　　　返回一个新的 String，它包含此序列当前所包含的字符子序列。该子字符串从指定的 start 处开始，一直到索引 end - 1 处的字符。<br>    　　参数（包左不包右）：<br>    　　　　start - 起始索引（包含）。<br>    　　　　end - 结束索引（不包含）。<br>    　　返回：<br>　　　　新的字符串。</p>
<h4 id="常用类和数据结构-包装类"><a href="#常用类和数据结构-包装类" class="headerlink" title="常用类和数据结构-包装类"></a>常用类和数据结构-包装类</h4><p>8 种 基本数据类型及对应的 8 种包装数据类型。<br>包装类型是为了解决基本数据类型无法面向对象编程所提供的。</p>
<table>
<thead>
<tr>
<th><strong>基本数据类型</strong></th>
<th><strong>包装类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<h4 id="包装类的数值转换"><a href="#包装类的数值转换" class="headerlink" title="包装类的数值转换"></a>包装类的数值转换</h4><p><img alt="包装类的数值转换，图片来源网络，侵删" data-src="http://eqgis.cn:13147/img/20191211/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2.png" class="lazyload"></p>
<h4 id="常用类和数据结构-容器类"><a href="#常用类和数据结构-容器类" class="headerlink" title="常用类和数据结构-容器类"></a>常用类和数据结构-容器类</h4><pre><code>Collection    
    Set    不能重复    
            HashSet、Vector
    List        
            ArrayList、linkedlist
Map    
    HashMap        
    HashTable    线程安全    </code></pre><p><img alt="collection,图片来源于网络，侵删" data-src="http://eqgis.cn:13147/img/20191211/collection.png" class="lazyload"></p>
<p><img alt="map,图片来源于网络，侵删" data-src="http://eqgis.cn:13147/img/20191211/map.png" class="lazyload"></p>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p><img alt="IO，图片来源于网络，侵删" data-src="http://eqgis.cn:13147/img/20191211/io%E6%B5%81.png" class="lazyload"></p>
<h5 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h5><pre><code>（1）字节流基类
1）InputStream
InputStream：字节输入流基类，抽象类是表示字节输入流的所有类的超类。
 常用方法：

    // 从输入流中读取数据的下一个字节
    abstract int read()
    // 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b中
    int read(byte[] b)
    // 将输入流中最多 len 个数据字节读入 byte 数组
    int read(byte[] b, int off, int len)
    // 跳过和丢弃此输入流中数据的 n个字节
    long skip(long n)

    // 关闭此输入流并释放与该流关联的所有系统资源
    void close()
2）OutputStream
OutputStream：字节输出流基类，抽象类是表示输出字节流的所有类的超类。
 常用方法：
    // 将 b.length 个字节从指定的 byte 数组写入此输出流
    void write(byte[] b)
    // 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流
    void write(byte[] b, int off, int len)
    // 将指定的字节写入此输出流
    abstract void write(int b)

    // 关闭此输出流并释放与此流有关的所有系统资源
    void close()

    // 刷新此输出流并强制写出所有缓冲的输出字节
    void flush()
（2）字节文件操作流
1）FileInputStream
FileInputStream：字节文件输入流，从文件系统中的某个文件中获得输入字节，用于读取诸如图像数据之类的原始字节流。
 构造方法：
    // 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的File对象file指定
    FileInputStream(File file)
    // 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的路径name指定
    FileInputStream(String name)

 常用方法：覆盖和重写了父类的的常用方法。
        // 读取f盘下该文件f://hell/test.txt
        //构造方法1
        InputStream inputStream = new FileInputStream(new File(&quot;f://hello//test.txt&quot;));
        int i = 0;
        //一次读取一个字节
        while ((i = inputStream.read()) != -1) {    
            // System.out.print(i + &quot; &quot;);// 65 66 67 68
            //为什么会输出65 66 67 68？因为字符在底层存储的时候就是存储的数值。即字符对应的ASCII码。
            System.out.print((char) i + &quot; &quot;);// A B C D
        }
        //关闭IO流
        inputStream.close();
        // 读取f盘下该文件f://hell/test.txt
        //构造方法2
        InputStream inputStream2 = new FileInputStream(&quot;f://hello/test.txt&quot;);
        // 字节数组
        byte[] b = new byte[2];
        int i2 = 0;
        //  一次读取一个字节数组
        while ((i2 = inputStream2.read(b)) != -1) {    
            System.out.print(new String(b, 0, i2) + &quot; &quot;);// AB CD
        }
        //关闭IO流
        inputStream2.close();
注： 一次读取一个字节数组，提高了操作效率,IO流使用完毕一定要关闭。
2）FileOutputStream
FileOutputStream：字节文件输出流是用于将数据写入到File，从程序中写入到其他位置。
 构造方法：
    // 创建一个向指定File对象表示的文件中写入数据的文件输出流
    FileOutputStream(File file)
    // 创建一个向指定File对象表示的文件中写入数据的文件输出流
    FileOutputStream(File file, boolean append)
    // 创建一个向具有指定名称的文件中写入数据的输出文件流
    FileOutputStream(String name)
    // 创建一个向具有指定name的文件中写入数据的输出文件流
    FileOutputStream(String name, boolean append)    
 常用方法：覆盖和重写了父类的的常用方法。
        OutputStream outputStream = new FileOutputStream(new File(&quot;test.txt&quot;));
        // 写出数据
        outputStream.write(&quot;ABCD&quot;.getBytes());
        // 关闭IO流
        outputStream.close();    
        // 内容追加写入
        OutputStream outputStream2 = new FileOutputStream(&quot;test.txt&quot;, true);
        // 输出换行符
        outputStream2.write(&quot;\r\n&quot;.getBytes());
        // 输出追加内容
        outputStream2.write(&quot;hello&quot;.getBytes());
        // 关闭IO流
        outputStream2.close();
注；输出的目的地文件不存在，则会自动创建，不指定盘符的话，默认创建在项目目录下;输出换行符时一定要写\r\n不能只写\n,因为不同文本编辑器对换行符的识别存在差异性。
（3）字节缓冲流（高效流）
1）.BufferedInputStream
BufferedInputStream：字节缓冲输入流，提高了读取效率。
     构造方法：
     // 创建一个 BufferedInputStream并保存其参数，即输入流in，以便将来使用。
     BufferedInputStream(InputStream in)
     // 创建具有指定缓冲区大小的 BufferedInputStream并保存其参数，即输入流in以便将来使用
     BufferedInputStream(InputStream in, int size)
        InputStream in = new FileInputStream(&quot;test.txt&quot;);
        // 字节缓存流
        BufferedInputStream bis = new BufferedInputStream(in);
        byte[] bs = new byte[20];
        int len = 0;
        while ((len = bis.read(bs)) != -1) {    
            System.out.print(new String(bs, 0, len));
            // ABCD
            // hello
        }
        // 关闭流
        bis.close();
2）BufferedOutputStream
BufferedOutputStream：字节缓冲输出流，提高了写出效率。
     构造方法：
     // 创建一个新的缓冲输出流，以将数据写入指定的底层输出流
     BufferedOutputStream(OutputStream out)
     // 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流
     BufferedOutputStream(OutputStream out, int size)

     常用方法：
     // 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流
     void write(byte[] b, int off, int len)
     // 将指定的字节写入此缓冲的输出流
     void write(int b)
     // 刷新此缓冲的输出流
     void flush()
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;test.txt&quot;, true));
        // 输出换行符
        bos.write(&quot;\r\n&quot;.getBytes());
        // 输出内容
        bos.write(&quot;Hello Android&quot;.getBytes());
        // 刷新此缓冲的输出流
        bos.flush();
        // 关闭流
        bos.close();</code></pre><h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><pre><code>（1）字符流基类
1）Reader
Reader:读取字符流的抽象类.
  常用方法：
    // 读取单个字符
    int read()
    // 将字符读入数组
    int read(char[] cbuf)
    // 将字符读入数组的某一部分
    abstract int read(char[] cbuf, int off, int len)
    // 跳过字符
    long skip(long n)

    // 关闭该流并释放与之关联的所有资源
    abstract void close()
2）Writer
Writer:写入字符流的抽象类.
 常用方法：
    // 写入字符数组
     void write(char[] cbuf)
    // 写入字符数组的某一部分
    abstract void write(char[] cbuf, int off, int len)
    // 写入单个字符
    void write(int c)
    // 写入字符串
    void write(String str)
    // 写入字符串的某一部分
    void write(String str, int off, int len)

    // 将指定字符添加到此 writer
    Writer append(char c)
    // 将指定字符序列添加到此 writer
    Writer append(CharSequence csq)
    // 将指定字符序列的子序列添加到此 writer.Appendable
    Writer append(CharSequence csq, int start, int end)

    // 关闭此流，但要先刷新它
    abstract void close()
    // 刷新该流的缓冲
    abstract void flush()
（2）字符转换流
1）InputStreamReader
InputStreamReader：字节流转字符流，它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。
 构造方法：
    // 创建一个使用默认字符集的 InputStreamReader
    InputStreamReader(InputStream in)
    // 创建使用给定字符集的 InputStreamReader
    InputStreamReader(InputStream in, Charset cs)
    // 创建使用给定字符集解码器的 InputStreamReader
    InputStreamReader(InputStream in, CharsetDecoder dec)
    // 创建使用指定字符集的 InputStreamReader
    InputStreamReader(InputStream in, String charsetName)
 特有方法：
    //返回此流使用的字符编码的名称 
    String getEncoding() 
        //使用默认编码        
        InputStreamReader reader = new InputStreamReader(new FileInputStream(&quot;test.txt&quot;));
        int len;
        while ((len = reader.read()) != -1) {
            System.out.print((char) len);//爱生活，爱Android

        }
        reader.close();

         //指定编码 
        InputStreamReader reader = new InputStreamReader(new FileInputStream(&quot;test.txt&quot;),&quot;utf-8&quot;);
        int len;
        while ((len = reader.read()) != -1) {
            System.out.print((char) len);//????????Android
        }
        reader.close();
注：Eclipse默认使用GBK编码,test.txt文件所以是GBK编码，当指定utf-8编码时所以会乱码。
2）OutputStreamWriter
OutputStreamWriter：字节流转字符流。
 构造方法：
    // 创建使用默认字符编码的 OutputStreamWriter
    OutputStreamWriter(OutputStream out)
    // 创建使用给定字符集的 OutputStreamWriter
    OutputStreamWriter(OutputStream out, Charset cs)
    // 创建使用给定字符集编码器的 OutputStreamWriter
    OutputStreamWriter(OutputStream out, CharsetEncoder enc)
    // 创建使用指定字符集的 OutputStreamWriter
    OutputStreamWriter(OutputStream out, String charsetName)
 特有方法：
    //返回此流使用的字符编码的名称 
    String getEncoding() 
（3）字符缓冲流（高效流）
1）.BufferedReader
BufferedReader：字符缓冲流，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。
 构造方法：
    // 创建一个使用默认大小输入缓冲区的缓冲字符输入流
    BufferedReader(Reader in)
    // 创建一个使用指定大小输入缓冲区的缓冲字符输入流
    BufferedReader(Reader in, int sz)
 特有方法：
    // 读取一个文本行
    String readLine()
        //生成字符缓冲流对象
        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;test.txt&quot;)));
        String str;
        //一次性读取一行
        while ((str = reader.readLine()) != null) {
            System.out.println(str);// 爱生活，爱Android
        }

        //关闭流
        reader.close();
2）BufferedWriter
BufferedWriter：字符缓冲流，将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。
 构造方法：
    // 创建一个使用默认大小输出缓冲区的缓冲字符输出流
    BufferedWriter(Writer out)
    // 创建一个使用给定大小输出缓冲区的新缓冲字符输出流
    BufferedWriter(Writer out, int sz)
 特有方法：
    // 写入一个行分隔符
    void newLine() 
（4）FileReader、FileWriter
 FileReader：InputStreamReader类的直接子类，用来读取字符文件的便捷类，使用默认字符编码。
 FileWriter：OutputStreamWriter类的直接子类，用来写入字符文件的便捷类，使用默认字符编码。</code></pre><h5 id="高效流效率对比"><a href="#高效流效率对比" class="headerlink" title="高效流效率对比"></a>高效流效率对比</h5><p>以下为实操记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取方式一  </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">		FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"f://滑板//HEEL_FLIP.mp4"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"HEEL_FLIP.mp4"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 开始时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 一次读取一个字节</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> ((len = inputStream.read()) != -<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            outputStream.write(len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 用时毫秒</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        System.out.println(System.currentTimeMillis() - begin);<span class="comment">// 耗时213195ms</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//关闭流释放资源</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        inputStream.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        outputStream.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取方式二</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"f://滑板//HEEL_FLIP.mp4"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"HEEL_FLIP.mp4"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 开始时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 一次读取一个字节数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bs)) != -<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            outputStream.write(bs, <span class="number">0</span>, len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        System.out.println(System.currentTimeMillis() - begin);<span class="comment">// 用时281毫秒</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        inputStream.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        outputStream.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取方式三：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"f://滑板//HEEL_FLIP.mp4"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(inputStream);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"HEEL_FLIP.mp4"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 开始时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> ((len = bis.read(bs)) != -<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            bos.write(bs, <span class="number">0</span>, len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//  bos.flush();</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 用时毫秒</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        System.out.println(System.currentTimeMillis() - begin);<span class="comment">// 耗时78ms</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        bis.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">       bos.close();</span></pre></td></tr></table></figure>

<h4 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h4><p>Throwable：有两个重要的子类：Exception（异常）和Error（错误），两者都包含了大量的异常处理类。</p>
<h5 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h5><p>是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。<br>    通常有<br>        Virtual MachineError（虚拟机运行错误）、<br>        NoClassDefFoundError（类定义错误）等。<br>    比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。<br>    这些错误是不可查的，非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。</p>
<h5 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h5><p>程序本身可以捕获并且可以处理的异常。</p>
<h6 id="Exception这种异常又分为两类：运行时异常和编译异常"><a href="#Exception这种异常又分为两类：运行时异常和编译异常" class="headerlink" title="Exception这种异常又分为两类：运行时异常和编译异常"></a>Exception这种异常又分为两类：运行时异常和编译异常</h6><p>1、运行时异常(不受检异常)：RuntimeException类极其子类表示JVM在运行期间可能出现的错误。比如说试图使用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</p>
<p>2、编译异常(受检异常)：Exception中除RuntimeException极其子类之外的异常。如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，否则编译不通过。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。</p>
<h6 id="可查异常与不可查异常：java的所有异常可以分为可查异常（checked-exception）和不可查异常（unchecked-exception）。"><a href="#可查异常与不可查异常：java的所有异常可以分为可查异常（checked-exception）和不可查异常（unchecked-exception）。" class="headerlink" title="可查异常与不可查异常：java的所有异常可以分为可查异常（checked exception）和不可查异常（unchecked exception）。"></a>可查异常与不可查异常：java的所有异常可以分为可查异常（checked exception）和不可查异常（unchecked exception）。</h6><p>1、可查异常：编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除RuntimeException及其子类外，其他的Exception异常都属于可查异常。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</p>
<p>2、不可查异常：编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</p>
<h6 id="对于不同的异常，java采用不同的异常处理方式。"><a href="#对于不同的异常，java采用不同的异常处理方式。" class="headerlink" title="对于不同的异常，java采用不同的异常处理方式。"></a>对于不同的异常，java采用不同的异常处理方式。</h6><p>1、运行异常将由系统自动抛出，应用本身可以选择处理或者忽略该异常。<br>2、对于方法中产生的Error，该异常一旦发生JVM将自行处理该异常，因此java允许应用不抛出此类异常。<br>3、对于所有的可查异常，必须进行捕获或者抛出该方法之外交给上层处理。也就是当一个方法存在异常时，要么使用try-catch捕获，要么使用该方法使用throws将该异常抛调用该方法的上层调用者。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">谭蕴修</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/http:/www.eqgis.cn/2019/12/11/2019-12-11-Java%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">http://www.eqgis.cn/2019/12/11/2019-12-11-Java%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.eqgis.cn">Ikkyu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/">回顾总结    </a></div><div class="post_share"><div class="social-share" data-image="http://eqgis.cn:13147/img/java.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/14/2019-12-14-JDBC%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95/"><img class="prev_cover lazyload" data-src="http://eqgis.cn:13147/img/java.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>时间格式转换、JDBC以及动态菜单</span></div></a></div><div class="next-post pull_right"><a href="/2019/12/10/2019-12-10-SQL%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/"><img class="next_cover lazyload" data-src="http://eqgis.cn:13147/img/Oracle.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>SQL部分知识点回顾</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/12/14/2019-12-14-JDBC以及动态菜单/" title="时间格式转换、JDBC以及动态菜单"><img class="relatedPosts_cover lazyload"data-src="http://eqgis.cn:13147/img/java.jpg"><div class="relatedPosts_title">时间格式转换、JDBC以及动态菜单</div></a></div><div class="relatedPosts_item"><a href="/2019/12/10/2019-12-10-SQL部分知识点回顾/" title="SQL部分知识点回顾"><img class="relatedPosts_cover lazyload"data-src="http://eqgis.cn:13147/img/Oracle.jpg"><div class="relatedPosts_title">SQL部分知识点回顾</div></a></div><div class="relatedPosts_item"><a href="/2019/10/30/2019-10-29-Linux常用命令/" title="Linux常用命令"><img class="relatedPosts_cover lazyload"data-src="http://eqgis.cn:13147/img/linux.jpg"><div class="relatedPosts_title">Linux常用命令</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(http://eqgis.cn:13147/img/java.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 By 谭蕴修</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="https://www.beianx.cn/eqgis.cn" target="_blank" rel="noopener"><span>蜀ICP备19032913号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>